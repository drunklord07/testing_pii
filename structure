import os
from collections import defaultdict

def write_tree_with_summary(root_dir, output_file):
    level1_counts = defaultdict(int)
    level2_counts = defaultdict(int)

    with open(output_file, 'w') as f:
        f.write(f"== Directory Tree for {root_dir} ==\n\n")

        for current_root, dirs, files in os.walk(root_dir):
            rel_path = os.path.relpath(current_root, root_dir)
            depth = rel_path.count(os.sep)
            indent = ' ' * 4 * depth
            folder_name = os.path.basename(current_root) if rel_path != '.' else os.path.basename(root_dir)
            f.write(f"{indent}{folder_name}/\n")

            for file in files:
                subindent = ' ' * 4 * (depth + 1)
                f.write(f"{subindent}{file}\n")

            # Count files for level 1 and 2
            if depth == 1:
                level1_counts[rel_path] += len(files)
            elif depth == 2:
                level2_counts[rel_path] += len(files)

        f.write("\n\n== Level 1 Directory Summary ==\n")
        for dir_name, count in sorted(level1_counts.items()):
            f.write(f"{dir_name} -> {count} files\n")

        f.write("\n== Level 2 Directory Summary ==\n")
        for dir_name, count in sorted(level2_counts.items()):
            f.write(f"{dir_name} -> {count} files\n")


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Generate directory tree and summary")
    parser.add_argument("directory", help="Root directory to scan")
    args = parser.parse_args()

    output_file = "tree_summary.txt"
    print(f"Scanning: {args.directory}")
    write_tree_with_summary(args.directory, output_file)
    print(f"Tree and summary written to: {output_file}")
