import os
import re
from pathlib import Path
from functools import lru_cache
from concurrent.futures import ProcessPoolExecutor
from tqdm import tqdm

# ======= HARDCODED INPUT PATH HERE =======
INPUT_FOLDER = r"C:\Your\Full\Input\Path\Here"  # ‚Üê CHANGE THIS
OUTPUT_FOLDER = "output_regex"
SUMMARY_FILE = "summary_report.txt"

# ======= FINAL REGEXES =======
PII_PATTERNS = {
    "MOBILE_REGEX": re.compile(r'(?<![A-Za-z0-9])(?:\+91|91|0)?[6-9][0-9]{9}(?![A-Za-z0-9])'),
    "AADHAAR_REGEX": re.compile(r'(?<![A-Za-z0-9])(\d{12})(?![A-Za-z0-9])'),
    "PAN_REGEX": re.compile(r'(?<![A-Za-z0-9])[A-Z]{5}[0-9]{4}[A-Z](?![A-Za-z0-9])', re.IGNORECASE),
    "GSTIN_REGEX": re.compile(r'(?<![A-Za-z0-9])[0-9]{2}[A-Z]{5}[0-9]{4}[A-Z][1-9A-Z]Z[0-9A-Z](?![A-Za-z0-9])', re.IGNORECASE),
    "DL_REGEX": re.compile(r'(?<![A-Za-z0-9])[A-Z]{2}[0-9]{2}[0-9]{11}(?![A-Za-z0-9])', re.IGNORECASE),
    "VOTERID_REGEX": re.compile(r'(?<![A-Za-z0-9])[A-Z]{3}[0-9]{7}(?![A-Za-z0-9])', re.IGNORECASE),
    "EMAIL_REGEX": re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,3}', re.IGNORECASE),
    "UPI_REGEX": re.compile(r'[a-zA-Z0-9.\-_]{2,256}@[a-zA-Z]{2,64}')
}

# ======= VERHOEFF FOR AADHAAR =======
verhoeff_table_d = [
    [0,1,2,3,4,5,6,7,8,9],
    [1,2,3,4,0,6,7,8,9,5],
    [2,3,4,0,1,7,8,9,5,6],
    [3,4,0,1,2,8,9,5,6,7],
    [4,0,1,2,3,9,5,6,7,8],
    [5,9,8,7,6,0,4,3,2,1],
    [6,5,9,8,7,1,0,4,3,2],
    [7,6,5,9,8,2,1,0,4,3],
    [8,7,6,5,9,3,2,1,0,4],
    [9,8,7,6,5,4,3,2,1,0]
]
verhoeff_table_p = [
    [0,1,2,3,4,5,6,7,8,9],
    [1,5,7,6,2,8,3,0,9,4],
    [5,8,0,3,7,9,6,1,4,2],
    [8,9,1,6,0,4,3,5,2,7],
    [9,4,5,3,1,2,6,8,7,0],
    [4,2,8,6,5,7,3,9,0,1],
    [2,7,9,3,8,0,6,4,1,5],
    [7,0,4,6,9,1,3,2,5,8]
]

@lru_cache(maxsize=None)
def is_valid_aadhaar(number: str) -> bool:
    c = 0
    for i, digit in enumerate(map(int, reversed(number))):
        c = verhoeff_table_d[c][verhoeff_table_p[i % 8][digit]]
    return c == 0

# ======= PROCESS EACH FILE =======
def process_file(filepath: str, input_root: str) -> dict:
    rel_path = os.path.relpath(filepath, input_root)
    output_path = os.path.join(OUTPUT_FOLDER, rel_path)
    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    counts = {
        "file": rel_path,
        "total_lines": 0,
        "matched_lines": 0,
        "no_match_lines": 0,
        "blank_lines": 0,
        "match_type_counts": {k: 0 for k in PII_PATTERNS}
    }

    with open(filepath, 'r', encoding='utf-8', errors='ignore') as f, \
         open(output_path, 'w', encoding='utf-8') as outf, \
         tqdm(desc=f"{rel_path}", unit="lines", leave=False) as pbar:

        for line in f:
            counts["total_lines"] += 1
            line = line.strip()
            if not line:
                counts["blank_lines"] += 1
                outf.write("\n")
                pbar.update(1)
                continue

            log_line, path = (line.rsplit(";", 1) if ";" in line else (line, ""))

            match_found = False
            for tag, pattern in PII_PATTERNS.items():
                if not pattern.search(log_line):
                    continue
                for match in pattern.finditer(log_line):
                    value = match.group(0)
                    if tag == "AADHAAR_REGEX" and not is_valid_aadhaar(value):
                        continue
                    outf.write(f"{log_line};{path} {value};{tag}\n")
                    counts["matched_lines"] += 1
                    counts["match_type_counts"][tag] += 1
                    match_found = True
            if not match_found:
                counts["no_match_lines"] += 1

            pbar.update(1)

    return counts

# ======= MAIN SCAN FUNCTION =======
def run_scan():
    input_root = INPUT_FOLDER
    os.makedirs(OUTPUT_FOLDER, exist_ok=True)

    all_files = [os.path.join(dp, f)
                 for dp, _, files in os.walk(input_root)
                 for f in files if f.endswith(".txt")]

    total_summary = {
        "files_scanned": 0,
        "total_lines": 0,
        "blank_lines": 0,
        "no_match_lines": 0,
        "total_matches": 0,
        "per_type": {k: 0 for k in PII_PATTERNS}
    }
    per_file_summary = []

    with ProcessPoolExecutor(max_workers=6) as executor:
        futures = [executor.submit(process_file, file, input_root) for file in all_files]

        for future in tqdm(futures, desc="Overall Progress"):
            result = future.result()
            total_summary["files_scanned"] += 1
            total_summary["total_lines"] += result["total_lines"]
            total_summary["blank_lines"] += result["blank_lines"]
            total_summary["no_match_lines"] += result["no_match_lines"]
            total_summary["total_matches"] += result["matched_lines"]
            for k in PII_PATTERNS:
                total_summary["per_type"][k] += result["match_type_counts"][k]
            per_file_summary.append(
                f"{result['file']}: {result['matched_lines']} matches, {result['no_match_lines']} no-match, {result['blank_lines']} blank"
            )

    with open(SUMMARY_FILE, "w", encoding="utf-8") as s:
        s.write("==== SUMMARY REPORT ====\n")
        s.write(f"Files Scanned: {total_summary['files_scanned']}\n")
        s.write(f"Total Lines: {total_summary['total_lines']}\n")
        s.write(f"Total PII Matches: {total_summary['total_matches']}\n")
        s.write(f"NO_MATCH Lines Skipped: {total_summary['no_match_lines']}\n")
        s.write(f"Blank Lines: {total_summary['blank_lines']}\n\n")
        s.write("== Match Type Breakdown ==\n")
        for k, v in total_summary["per_type"].items():
            s.write(f"{k}: {v}\n")
        s.write("\n== Per File Summary ==\n")
        for line in per_file_summary:
            s.write(line + "\n")

if __name__ == "__main__":
    run_scan()
