import os
import re

# ========= CONFIGURATION ========= #
INPUT_FOLDER = "/your/path/to/input/folder"  # ‚Üê üîß Set your folder path here
# ================================= #

base_name = os.path.basename(os.path.normpath(INPUT_FOLDER))
OUTPUT_FOLDER = f"mobile_fixed_{base_name}"
SUMMARY_FILE = "mobile_cleanup_summary.txt"
REMOVED_LINES_FILE = "removed_lines.txt"

# Pattern to identify MOBILE_REGEX triplets
MOBILE_TRIPLET_PATTERN = re.compile(r";no_field;([^;]+);MOBILE_REGEX;", re.IGNORECASE)

# Patterns for keeping lines if other valid PII present
OTHER_VALID_PATTERNS = [
    re.compile(r";no_field;[^;]+;CARD_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;AADHAAR_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;PAN_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;VOTERID_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;EMAIL_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;GSTIN_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;DL_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;IP_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;MAC_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;COORD_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;UPI_REGEX;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;ADDRESS_KEYWORD;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;NAME_KEYWORD;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;DOB_KEYWORD;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;ACCOUNT_NUMBER_KEYWORD;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;CUSTOMER_ID_KEYWORD;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;SENSITIVE_HINTS_KEYWORD;", re.IGNORECASE),
    re.compile(r";no_field;[^;]+;INSURANCE_POLICY_KEYWORD;", re.IGNORECASE),
]

def is_valid_mobile_number(value: str, full_line: str) -> bool:
    """
    Check if value is a valid mobile number and occurs standalone or inside string/JSON/XML.
    """
    # Format check: either 10 digits (6‚Äì9) or 12 digits starting with 91 then 6‚Äì9
    if not (re.fullmatch(r"[6-9]\d{9}", value) or re.fullmatch(r"91[6-9]\d{9}", value)):
        return False

    # Locate full triplet to isolate the log part
    triplet = f";no_field;{value};MOBILE_REGEX;"
    triplet_index = full_line.find(triplet)
    if triplet_index == -1:
        return False
    log_content = full_line[:triplet_index]

    # Search for all exact matches of value in the log part
    for match in re.finditer(re.escape(value), log_content):
        start, end = match.start(), match.end()
        left = log_content[start - 1] if start > 0 else ''
        right = log_content[end] if end < len(log_content) else ''

        if left.isalnum() or right.isalnum():
            continue  # Invalid if surrounded by alphanumeric characters

        # If it's in quotes, brackets, JSON/XML, it's valid
        if left in ['"', "'", "(", "[", "{", ":", ">"] or right in ['"', "'", ")", "]", "}", "<", ","]:
            return True
        # Also valid if surrounded by space or punctuation
        if left in [' ', ':', ',', ';', '=', '-'] or right in [' ', ':', ',', ';', '=', '-']:
            return True

    return False  # No valid context found

def has_other_valid_matches(line: str) -> bool:
    return any(p.search(line) for p in OTHER_VALID_PATTERNS)

def process_line(line: str):
    original_line = line
    removed_count = 0
    matches = MOBILE_TRIPLET_PATTERN.findall(line)

    for match in matches:
        if not is_valid_mobile_number(match, original_line):
            line = line.replace(f";no_field;{match};MOBILE_REGEX;", "")
            removed_count += 1

    # Clean double semicolons (e.g. ;;)
    line = re.sub(r";{2,}", ";", line)
    line = line.strip("; \n") + "\n"

    if removed_count == len(matches) and not has_other_valid_matches(original_line):
        return None, removed_count, True, original_line
    return line, removed_count, False, None

def print_progress(current, total, width=40):
    done = int(width * current / total)
    bar = f"[{'‚ñà' * done}{'.' * (width - done)}] {current}/{total}"
    print(f"\r{bar}", end='', flush=True)

def main():
    if not os.path.isdir(INPUT_FOLDER):
        print(f"‚ùå Error: '{INPUT_FOLDER}' is not a valid directory.")
        return

    os.makedirs(OUTPUT_FOLDER, exist_ok=True)

    files = [f for f in os.listdir(INPUT_FOLDER) if f.endswith(".txt")]
    total_files = len(files)
    total_lines = 0
    total_removed = 0
    total_remaining = 0
    total_lines_deleted = 0
    total_written_files = 0
    skipped = []
    removed_lines = []

    for idx, file in enumerate(files, 1):
        input_path = os.path.join(INPUT_FOLDER, file)
        output_path = os.path.join(OUTPUT_FOLDER, file)

        try:
            with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()

            new_lines = []
            removed_here = 0
            deleted_lines = 0
            mobile_remaining = 0

            for line in lines:
                total_lines += 1
                cleaned, removed_count, deleted, original_line = process_line(line)
                if deleted:
                    total_lines_deleted += 1
                    deleted_lines += 1
                    removed_lines.append(original_line)
                    continue
                if cleaned:
                    new_lines.append(cleaned)
                    mobile_remaining += len(MOBILE_TRIPLET_PATTERN.findall(cleaned))
                removed_here += removed_count

            with open(output_path, "w", encoding="utf-8") as f:
                f.writelines(new_lines)

            total_removed += removed_here
            total_remaining += mobile_remaining
            total_written_files += 1

        except Exception as e:
            skipped.append((file, str(e)))

        print_progress(idx, total_files)

    print("\n‚úÖ Done.\n")

    with open(SUMMARY_FILE, "w", encoding="utf-8") as f:
        f.write("=== MOBILE_REGEX Cleanup Summary ===\n")
        f.write(f"üìÇ Total files scanned: {total_files}\n")
        f.write(f"üìù Total lines scanned: {total_lines}\n")
        f.write(f"‚ùå MOBILE_REGEX matches removed: {total_removed}\n")
        f.write(f"‚úÖ MOBILE_REGEX matches remaining: {total_remaining}\n")
        f.write(f"üóëÔ∏è Lines deleted (only invalid mobile matches): {total_lines_deleted}\n")
        f.write(f"üìÅ Files successfully written: {total_written_files}\n")
        if skipped:
            f.write("\n=== Skipped Files ===\n")
            for name, reason in skipped:
                f.write(f"{name} ‚Üí {reason}\n")
        f.write("====================================\n")

    if removed_lines:
        with open(REMOVED_LINES_FILE, "w", encoding="utf-8") as f:
            f.writelines(removed_lines)
        print(f"üóëÔ∏è Removed lines saved to: {REMOVED_LINES_FILE}")

    print(f"üìÅ Output folder: {OUTPUT_FOLDER}")
    print(f"üìÑ Summary: {SUMMARY_FILE}")

if __name__ == "__main__":
    main()
